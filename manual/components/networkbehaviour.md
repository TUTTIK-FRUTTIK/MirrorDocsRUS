# Network Behaviour

{% hint style="info" %}
Смотрите также [NetworkBehaviour](https://mirror-networking.com/docs/api/Mirror.NetworkBehaviour.html) в API Reference.
{% endhint %}

Network Behaviour скрипт работает с игровыми объектами имеющими компонент Network Identity. Скрипты унаследованные от Network Behaviour могут выполнять высокоуровневые функции API, такие как Command, ClientRpc, и SyncVars.

{% hint style="danger" %}
Не выкладывайте объекты в `DontDestroyOnLoad` (DDOL) в Awake().\
Вместо этого вы можете это сделать в методе Start().
{% endhint %}

При использовании сервер-авторитарной системы Mirror, сервер должен использовать `NetworkServer.Spawn` чтобы спавнить объекты имеющие компонент Network Identity. При создании их таким образом им присваивается `NetId` и они заодно создаются на клиентах, подключенных к серверу.

**Примечание:** Это не компонент, который вы можете добавить непосредственно к игровому объекту. Вместо этого вы должны создать скрипт, который наследуется от `NetworkBehaviour` (вместо `MonoBehaviour`, который стоит по умолчанию), затем вы можете добавить свой скрипт в качестве компонента к игровому объекту.

## Свойства <a href="#properties" id="properties"></a>

* **isServer**\
  Возвращает значение true в контексте сервера, если этот игровой объект был заспавнен.
* **isClient**\
  Возвращает значение true в контексте клиента, если этот игровой объект был заспавнен сервером.
* **isLocalPlayer**\
  Возвращает значение true для клиента, если этот игровой объект является игроком, созданным для этого клиента.
* **isOwned** (ранее `hasAuthority`)\
  Возвращает значение true для клиента, если у этого клиента есть [власть](../guides/authority.md) над этим игровым объектом. Это бессмысленно в контексте сервера, так как у сервера есть власть над всеми объектами.
* **netId**\
  Уникальный сетевой идентификатор этого игрового объекта. Сервер назначает это во время выполнения. Он уникален для всех игровых объектов в сети.
* **netIdentity**\
  Возвращает Network Identity этого объекта
* **connectionToServer**\
  Сетевое подключение, связанное с компонентом сетевой идентификации, прикрепленным к этому игровому объекту. Это значение действительно только для **локального объекта игрока** на клиенте и равно null для других объектов player, которые могут существовать на клиенте.
* **connectionToClient**\
  Сетевое подключение, связанное с компонентом сетевой идентификации, прикрепленным к этому игровому объекту. Это действительно для игровых объектов на сервере, которые были назначены конкретному клиенту, например, объекты игроков, домашние животные, приспешники или другие объекты, которыми "владеет" один клиент.

Скрипты Network Behaviour обладают следующими функциями:

* Синхронизирование переменных
* Сетевые обратные вызовы
* Серверные и клиентские функции
* Отправка команд \[Command]
* Вызовы Client RPC
* Сетевые события

![](<../../.gitbook/assets/image (6) (1).png>)

## Сетевые обратные вызовы <a href="#network-callbacks" id="network-callbacks"></a>

Встроенные сетевые функции запускаемые в скриптах Network Behaviour для различных сетевых событий. Это виртуальные функции базового класса, поэтому вы можете переопределить их в своем собственном коде следующим образом:

```csharp
public class SpaceShip : NetworkBehaviour
{
    public override void OnStartServer()
    {
        // делайте что нибудь на стороне сервера
    }

    public override void OnStartClient()
    {
        // регистрируйте клиентские события, включайте эффекты
    }
}
```

Встроенными обратными вызовами являются:

* **OnStartServer** вызывается на сервере, когда игровой объект появляется на сервере или когда сервер запускается для игровых объектов в сцене
* **OnStopServer** вызывается на сервере, когда игровой объект уничтожается на сервере или когда сервер останавливается для игровых объектов в сцене
* **OnStartClient** вызывается на клиентах, когда игровой объект появляется на клиенте, или когда клиент подключается к серверу для игровых объектов в сцене
* **OnStopClient** вызывается на клиентах, когда сервер уничтожает игровой объект
* **OnStartLocalPlayer** вызывается на клиенте после `OnStartClient` для игрового объекта игрока на локальном клиенте
* **OnStopLocalPlayer** вызывается на клиенте перед `OnStopClient` для игрового объекта игрока на локальном клиенте
* **OnStartAuthority** вызывается на клиенте-владельце при назначении полномочий сервером. `isOwned` будет верно для таких объектов в контексте клиента.
* **OnStopAuthority** вызывается на клиенте-владельце, когда сервер удаляет полномочия.

Обратите внимание, что при одноранговой настройке, когда один из клиентов выступает одновременно и в качестве хоста, и в качестве клиента, `OnStartServer` и `OnStartClient` будут вызваны на одном и том же объекте. Обе эти функции полезны для действий, специфичных либо для клиента, либо для сервера, таких как выключение эффектов на сервере или настройка событий на стороне клиента.

## Атрибуты клиента и сервера <a href="#server-and-client-functions" id="server-and-client-functions"></a>

Вы можете помечать методы в скриптах Monobehaviour и Network Behaviour с пользовательскими атрибутами для обозначения их как функций только для сервера или только для клиента. `[Server]` и `[ServerCallback]` немедленно вызываются если клиент не активен. Также, `[Client]` и `[ClientCallback]` немедленно вызываются если сервер не активен.

Атрибуты `[Server]` и `[Client]` не генерируют ошибок во время компиляции, но они выдают предупреждающее сообщение журнала, если вызываются в неправильном контексте, к примеру если клиент попытается исполнить метод с атрибутом \[Server] или наоборот.

Атрибуты `ServerCallback` и `ClientCallback` действуйте так же, как описано выше, но не выдает предупреждения.

Для получения дополнительной информации, смотрите раздел [Атрибуты](../guides/attributes.md).

## Command <a href="#commands" id="commands"></a>

Чтобы выполнить код на сервере, вы должны использовать команды. Высокоуровневый API - это система, зависящая от сервера, поэтому команды - это единственный способ для клиента запустить какой-либо код на сервере.

Обычно команды могут быть только у объектов игроков, однако они также могут существовать в других сетевых объектах и могут вызываться клиентом, которому назначены полномочия для этого объекта, или любым клиентом, который применил [обход полномочий](../guides/communications/remote-actions.md).

Когда клиентский игровой объект игрока отправляет команду, эта команда выполняется в соответствующем игровом объекте игрока на сервере. Эта маршрутизация происходит автоматически, поэтому клиент не может отправить команду другому игроку.

Чтобы создать команду в вашем коде, вы должны украсить метод атрибутом \[Command]. Хотя это и не требуется, настоятельно рекомендуется добавлять к именам методов префикс `Cmd`, чтобы в вашем вызывающем коде было легче распознать, что будет происходить.

Команды вызываются просто путем обычного вызова метода на клиенте. Вместо метода, запущенного на клиенте, он автоматически вызывается для соответствующего игрового объекта игрока на сервере.

Команды безопасны по типу, имеют встроенную защиту и маршрутизацию к объекту игрока, а также используют эффективный механизм сериализации аргументов для ускорения их вызова.

Смотрите [Коммуникации](../guides/communications/) и соответствующие разделы для получения дополнительной информации.

## Вызовы Client RPC <a href="#client-rpc-calls" id="client-rpc-calls"></a>

Вызовы Client RPC это способ для серверных игровых объектов заставить что-то происходить с клиентскими игровыми объектами.

Вызовы Client RPC не ограничиваются игровыми объектами игрока, и могут быть вызваны для любого игрового объекта к компонентом Network Identity.

Чтобы вызвать RPC-вызов в вашем коде, вы должны украсить метод с помощью `[ClientRpc]`. Хотя это и не требуется, настоятельно рекомендуется добавлять к именам методов префикс `Rpc`, чтобы в вашем вызывающем коде было легче распознать, что будет происходить.

Смотрите [Коммуникации](../guides/communications/) и соответствующие разделы для получения дополнительной информации.

## Сетевые события (Устарело) <a href="#networked-events-obsolete" id="networked-events-obsolete"></a>

> **ВАЖНО** SyncEvents были удалены в версии 18.0.0, смотрите [Issue](https://github.com/vis2k/Mirror/pull/2178) для получения дополнительной информации

Это сетевые события по типу вызовов Client RPC, но вместо того, чтобы вызывать функцию для игрового объекта, они запускают события.

Это позволяет вам писать сценарии, которые могут регистрироваться для обратного вызова при срабатывании события.

Чтобы определить сетевое событие в вашем коде, вы должны написать функцию, которая одновременно:

* Имеет имя, начинающееся с `Event`
* Имеет атрибут `SyncEvent`

Вы можете использовать события для создания мощных сетевых игровых систем, которые могут быть расширены с помощью других скриптов. В этом примере показано, как сценарий эффекта на клиенте может реагировать на события, генерируемые боевым сценарием на сервере.

SyncEvent - это базовый класс, производными от которого являются команды и вызовы ClientRpc. Вы можете использовать атрибут SyncEvent в своих собственных функциях, чтобы создать свой собственный управляемый событиями сетевой игровой код. Используя SyncEvent, вы можете расширить многопользовательские функции Mirror, чтобы они лучше соответствовали вашим собственным шаблонам программирования.

Смотрите раздел [SyncEvents](../guides/synchronization/syncevent.md) для получения более подробной информации.
