# Network Authenticators

Когда у вас многопользовательская игра, часто вам нужно сохранить информацию о вашем игроке для последующих игр, вести игровую статистику или общаться со своими друзьями. Для всех этих вариантов использования часто требуется способ уникальной идентификации пользователя. Способность различать пользователей называется аутентификацией. Существует несколько доступных методов, некоторые примеры включают:

* Запрос у игрока имени и пароля
* Использование OAuth2 или OpenID identity provider, по типу Facebook, Twitter, Google
* Использование сервисов по типу PlayFab, GameLift или Steam
* Использование device id, очень популярный метод в мобильных устройствах
* Использование Google Play в Android
* Использование Game Center в IOS
* Использование веб сервиса на вашем веб сайте

## Шифрование <a href="#encryption-notice" id="encryption-notice"></a>

Немногие из доступных транспортов поддерживают шифрование, поэтому, если вы хотите выполнить аутентификацию через Mirror, мы настоятельно рекомендуем вам использовать транспорт, который поддерживает это, к примеру [SimpleWebSocket](https://mirror-networking.gitbook.io/docs/transports/websockets-transport), или осуществлять обмен конфиденциальными данными с помощью UnityWebRequest с сервисом вместо HTTPS. Это можно сделать внутри аутенфикатора, или перед вызовом `StartClient`.

## Offline / Online сцены

Аутентификация происходит в оффлайн сцене, и обмен сообщениями с игровым сервером осуществляется на этапе предварительного подключения, поэтому клиент остается в оффлайн сцене до завершения аутентификации.

## Сохранение данных

`NetworkConnection` имеет **`authenticationData`** со свойствами типа `Object`, это может быть установлено практически на все, что вам нужно, например, идентификаторы учетной записи, токены, выбор персонажа и т.д., включая структуру данных на сервере и/или клиенте во время процесса аутентификации. Эти данные доступны везде в Mirror, где у вас есть данные клиента `NetworkConnection`...  Просто приведите его обратно к тому типу, который вы в него ввели.

## Встроенные аутенфикаторы <a href="#basic-authenticator" id="basic-authenticator"></a>

* [Basic Authenticator](basic-authenticator.md)\
  Зеркало включает в себя базовый аутентификатор в папке Mirror / Authenticators, который просто использует простое имя пользователя и пароль.
*   [Device Authenticator](device-authenticator.md)

    Использует `SystemInfo.deviceUniqueIdentifier` на поддерживаемых платформах, и GUID в PlayerPrefs в качестве запасного варианта для платформ, которые это не поддерживают.

## Кастомные аутенфикаторы <a href="#custom-authenticators" id="custom-authenticators"></a>

Классы аутенфикаторов являются производными от базового абстрактного класса `Authenticator`, поэтому вы можете написать свой наследованный скрипт от данного класса.

Из Assets menu, кликните Create > Mirror > Network Authenticator чтобы создать свой собственный скрипт Аутенфикатора по [шаблонам скриптов](../../general/script-templates.md), и просто заполните сообщения и код подтверждения в соответствии с вашими потребностями. Когда клиент успешно проходит аутентификацию, вызывайте `ServerAccept(conn)` на сервере и `ClientAccept()` на клиенте. Mirror прослушивает эти события, чтобы продолжить последовательность подключения. Подпишитесь на события `OnServerAuthenticated` и `OnClientAuthenticated` если вы хотите выполнить дополнительные действия после аутентификации.

## Регистрация сообщений <a href="#message-registration" id="message-registration"></a>

По умолчанию все сообщения, зарегистрированные на `NetworkServer` и `NetworkClient` требуется проверка подлинности, если явно не указано иное. Чтобы зарегистрировать сообщения для обхода аутентификации, вам необходимо указать `false` для параметра bool в методе `RegisterMessage`:

```csharp
NetworkServer.RegisterHandler(OnAuthRequestMessage, false);
```

Некоторые внутренние сообщения уже настроены на обход аутентификации:

* Server
  * `NetworkPingMessage`
* Client
  * `SceneMessage`
  * `NetworkPongMessage`

## Tips

* Зарегистрируйте обработчики сообщений в `OnStartServer` и `OnStartClient`. Они вызываются из startServer/StartHost и StartClient.
* Отправьте сообщение клиенту, если аутентификация завершится неудачно, особенно если есть какая-то проблема, которую они могут решить.
* Вызывайте метод `Disconnect()` для `NetworkConnection` на сервере и клиенте когда аутенфикация прошла не успешно. Если вы хотите дать пользователю несколько попыток правильно ввести свои учетные данные, вы, конечно, можете это сделать, Mirror не выполнит отключение за вас.
  * Не забудьте установить небольшую задержку при вызове разъединения на сервере, если вы отправляете сообщение об ошибке, чтобы у него был шанс быть доставленным до того, как соединение будет разорвано. Как минимум, подождите один кадр.

Теперь, когда у вас есть основа пользовательского компонента аутентификации, остальное зависит от вас. Вы можете обмениваться любым количеством пользовательских сообщений между сервером и клиентом по мере необходимости, чтобы завершить процесс аутентификации перед утверждением клиента.

Аутентификация также может быть распространена на выбор персонажа и его настройку, просто путем создания дополнительных сообщений и обмена ими с клиентом перед завершением процесса аутентификации. Это означает, что этот процесс происходит до того, как клиент-игрок фактически войдет в игру или переключится на онлайн-сцену.

Если вы пишете хороший аутентификатор, подумайте о том, чтобы поделиться им с другими пользователями или пожертвовать его проекту Mirror.
