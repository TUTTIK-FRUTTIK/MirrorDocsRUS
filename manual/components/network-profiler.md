# Network Profiler

Mirror Profiler является частью подписки Mirror Pro. На момент написания этой статьи он доступен для наших [Спонсоров на GitHub](https://github.com/sponsors/vis2k).

![](<../../.gitbook/assets/image (51).png>)

## Установка <a href="#installation" id="installation"></a>

1. Убедитесь, что у вас установлена последняя версия Mirror.
2. Станьте [спонспором на GitHub](https://github.com/sponsors/vis2k) если вы этого еще не сделали.
3. Посетите Mirror Networking Discord. В канале информации вы узнаете, как присоединиться к каналу github\_sponsors.
4. В канале _github\_sponsors_ закрепленные сообщения подскажут вам, как загрузить профилировщик.
5. Установите пакет unity в свой проект.

## Использование

1. В меню Unity, кликните на Open Window -> Analysis -> Mirror Network Profiler. Появится окно profiler
2. Вы можете закрепить profiler в любом месте, где захотите
3. Запустите свою игру в редакторе
4. Нажмите "Record" в profiler'e
5. Начните свою игру в качестве хоста, клиента или сервера
6. Вверху на диаграмме будут показаны входящие и исходящие сообщения
7. Щелкните по диаграмме, чтобы выбрать рамку
8. Profiler отобразит информацию обо всех сообщениях, отправленных и полученных в текущем кадре

В настоящее время в сообщениях отображаются следующие поля:

* In/Out: Было ли сообщение получено (in) или отправлено (out)
* Name: Краткое название сообщения, если сообщение было `[Command]`, `[ClientRpc]`, `[TargetRpc]` или `[TargetEvent]`, при этом будет отображено имя метода, в противном случае будет отображено имя класса message.
* Bytes: Размер сообщения в байтах
* Count: В случае исходящих сообщений здесь будет указано, скольким клиентам было отправлено сообщение.
* Total Bytes: размер сообщения, умноженный на количество клиентов, которым было отправлено сообщение (Bytes \* Count)
* Channel: Канал, использованный для отправки сообщения. На момент написания этой статьи мы не можем определить канал для входящих сообщений, поэтому отображается значение -1. Это будет улучшено в будущих версиях. Транспортные средства могут использовать каналы для многих целей, таких как надежные, ненадежные, зашифрованные, сжатые и т.д.

## Optimizing bandwidth <a href="#optimizing-bandwidth" id="optimizing-bandwidth"></a>

На большинстве транспортных систем общая пропускная способность определяется столбцом Count. Это происходит потому, что каждое сообщение упаковано во фрейм TCP или UDP, которые имеют большие заголовки.

* Если вы отправляете несколько `[Command]` в одном и том же кадре рассмотрите возможность объединения их в единый `[Command]`, если в этом есть смысл
* Если вы видите большое число Count в определенном сообщении, подумайте о добавлении NetworkProximityChecker к вашему объекту, чтобы он был виден только ближайшим игрокам, а не всему миру. Это может значительно сократить количество (и общее количество байт) в зависимости от вашей игры.
* Если вы отправляете сообщение каждый отдельный кадр, подумайте о том, чтобы изменить свою логику таким образом, чтобы вы отправляли сообщения только тогда, когда что-то меняется, или используйте таймер.
* Рассмотрите возможность использования функции SyncToOwner, чтобы только владелец получал сообщение при изменении личной информации, такой как инвентарь. Это может значительно сократить количество сообщений в зависимости от вашей игры.
* Если у вас вызывается много`[ClientRpc]` которые синхронизируют данные, рассмотрите возможность использования`[SyncVar]` и synclists вместо этого. Они могут уменьшить количество сообщений, потому что отправляют дельты только при их изменении, плюс они группируются вместе, так что сотни переменных могут быть синхронизированы с одним сообщением.
